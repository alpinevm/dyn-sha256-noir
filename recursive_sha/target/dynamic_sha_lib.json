{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":12219390342068189353,"abi":{"parameters":[{"name":"expected_hash_encoded","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},{"name":"encoded_data","type":{"kind":"array","length":1033,"type":{"kind":"field"}},"visibility":"public"}],"param_witnesses":{"encoded_data":[{"start":2,"end":1035}],"expected_hash_encoded":[{"start":0,"end":2}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"zd3BahxHFIbRd5m1Fn3/6q6q1quEEGRbDgIjGUsOBON3j+w4IsYDxr2QznKkvtJdFB/DMIf6dHpz/erjn3/c3L69uz9d/vbp9O7u9dXDzd3t46tPp+Xrj+7fX91+eXX/cPXh4XTZZ784Xd++OV2OGp8vTm9v3l2fLtf++eKHR/dZ3x6tpdrTs8mZZ6vt//3dWtt3D/9+cSpmkzCbNGaTldlkYzbpzCaD2WQym+xO2aDIOpUtJ7PldLac0JZT2nJSW05ry4ltObWNU9tA72md2sapbZzaxqltnNrGqW2c2sapbXNq25zaNugjBKe2zaltc2rbnNo2p7bNqW1zars6tV2d2q5ObVfoE1untqtT29Wp7erUdnVquzq13Zzabk5tN6e2m1Pbzant5tR2c2q7ObXdnNpuTm27U9vu1LY7te1ObbtT2w59H8GpbXdq253adqe2w6ntcGo7nNoOp7bDqe1wajugr385tR1ObYdT2+nUdjq1nU5tp1Pb6dR2OrWdTm0n9G1bp7bTqe3u1HZ3ars7td2d2u5ObXentrtT292p7Q7hBkk3QLxhgXzDAgGHBRIOi5PcWiDjsEDIYYGUwwIxhwXqLsXKoO5KsEySZRItk2yZhMskXSbxMsiXFQTMChJmBRGzgoxZQcisIGVWEDMryJkVBM0KkmYFUbOCrFlB2KwgbVYQNyvImxUEzgoSZwWRs4LMWUHorCB1VhA7K8idFQTPCpJnBdGzguxZQfisIH1WED8ryJ8VBNAKEmgFEbSCDFpBCK0ghVYQQyvIoRUE0QqSaAVRtIIsWkEYrSCNVhBHK8ijFQTSChJpBZG0gkxaQSitIJVWEEsryKUVBNMKkmkF0bSCbFpBOK0gnVYQTyvIpxUE1AoSagURtYKMWkFIrSClVhBTK8ipFQTVCpJqBVG1gqxaQVitIK1WEFcryKsF8mqBvFogrxbIq2VxuhvIqwXyaoG8WiCvFsirBfJqgbxaIK8WyKsF8mqBvFogrxbIqwXyapHuQ5MuRKNuRIO6K92JJl2KJt2KJl2LJt2LJl2MBnm1QF4tkFcL5NUCebVAXi2QVwvk1QJ5tUBeLZBXC+TVAnm1QF4tkFcL5NUCebVAXi2QVwvk1QJ5tUBeLZBXC+TVAnm1QF4tkFcL5NUCebVAXi2QVwvk1QJ5tUBeLZBXC+TVAnm1QF4tkFcL5NUCebVAXi2QVwvk1QJ5tUBeLZBXC+TVAnm1QF4tkFcL5NUCebVAXi2QVwvk1QJ5tUBeLZBXC+TVAnm1QF4tkFcL5NUCebVAXi2QVwvk1QJ5tUBeLZBXa5BXa5BXa5BXa5BXa4vT3QZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tQZ5tXbeq81l/TYzt+3Zdjnv1V5ol4J2CbRLg3ZZoV02aJcO7TKgXSa0C9TdFeruCnV3hbp73qvtfTz9g+X53jScB2svtcwmLdOlZYa0zJSW2aFlzrO1l1qmpGUiLSMVeJMKvEkF3qQCb1KBN6nAm1TgLhW4SwXuUoG7VOAuFbhLBe5SgbtU4C4VuEsFHlKBh1TgIRV4SAUeUoGHVOAhFXhIBR5SgYdU4CkVeEoFnlKBp1TgKRV4SgWeUoGnVOApFXhKBT7P22pp+9N/GPP5tilqm1DbnI1wpT2dm/Tl/9t8HVp/OjTGD0PbkaF+ZGgcGZpHhvZfH1rPG6SfDdWRoRwZakeG1iND25GhfmRoHBmaR4aOnIg6ciLqyImoIyeijpyIOnIi6siJqCMnoo6ciDpyIurIiciRE5EjJyJHTkSOnIgcORH55RPx+OKvqw83V6/eXd8/jnz53cfb1w83d7ffXj78/f7f3zw++w8=","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"46":{"source":"use dep::std;\n\n// Amount of bytes this circuit will consume from encoded_data\nglobal BYTELEN = 226;\n// the amount of Field chunks needed to store BYTELEN amount of u8s should always be => ceil(BYTELEN/31)\nglobal BYTELEN_CHUNK = (BYTELEN + 30) / 31;\n// overflow, if bytelen mod 31 is equal to 0 then we set overflow equal to 31\nglobal OVERFLOW = (BYTELEN % 31) + ((BYTELEN % 31 == 0) as u32 * 31);\nglobal MAX_BYTE_CHUNKS = 1033;\n\n#[recursive]\nfn main(expected_hash_encoded: pub [Field; 2], encoded_data: pub [Field; MAX_BYTE_CHUNKS]) {\n\tassert(MAX_BYTE_CHUNKS >= (BYTELEN/BYTELEN_CHUNK));\n\tlet mut data: [u8; BYTELEN] = [0; BYTELEN];\n\tfor i in 0..BYTELEN_CHUNK-1 {\n\t\tlet decoded_field = encoded_data[i].to_be_bytes(31);\n\t\tfor j in 0..31 {\n\t\t\tdata[(i*31)+j] = decoded_field[j];\n\t\t}\n\t}\n\tlet decoded_field = encoded_data[BYTELEN_CHUNK-1].to_be_bytes(OVERFLOW);\n\tfor i in 0..OVERFLOW {\n\t\tdata[((BYTELEN_CHUNK-1)*31)+i] = decoded_field[i];\n\t}\n\tlet expected_hash_l1: [u8] = expected_hash_encoded[0].to_be_bytes(31);\n\tlet expected_hash_l2: [u8] = expected_hash_encoded[1].to_be_bytes(1);\n\tlet mut expected_hash: [u8; 32] = [0; 32];\n\tfor i in 0..31{\n\t\texpected_hash[i] = expected_hash_l1[i];\t\n\t}\n\texpected_hash[31] = expected_hash_l2[0];\n\tassert(std::hash::sha256(data) == expected_hash);\n}\n\n#[test]\nfn simple_test(){\n\t// using 63 as bytelen\n\tlet mut encoded_data: [Field; MAX_BYTE_CHUNKS] = [0; MAX_BYTE_CHUNKS];\n\tencoded_data[0] = 0x11111111111111111111111111111111111111111111111111111111111111;\n\tencoded_data[1] = 0xddddddddddddddddddaddddddddddddddddddddddddddddddddddddddddddd;\n\tencoded_data[2] = 0xdd;\n\tmain(\n\t\t[0x9f41fb1adcfc3bbe3f6b1df9f008c33eefeddcc7dcdd7266c5c5ddadda0398, 0xb5],\n\t\tencoded_data\n\t);\n}\n","path":"/home/alpinevm/Development/rift/dyn-sha256-noir/recursive_sha/src/main.nr"}},"names":["main"]}